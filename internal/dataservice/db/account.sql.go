// Code generated by sqlc. DO NOT EDIT.
// source: account.sql

package db

import (
	"context"
	"database/sql"
	"log"
)

const CreateAccount = `-- name: CreateAccount :one
insert into public.account (
    id,
    name,
    created_date,
    modified_date)
values(
    $1,
    $2,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
)
RETURNING id
`

type CreateAccountParams struct {
	ID   string
	Name sql.NullString
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (string, error) {
	row := q.db.QueryRow(ctx, CreateAccount, arg.ID, arg.Name)
	var id string
	err := row.Scan(&id)
	return id, err
}

const GetAccount = `-- name: GetAccount :one
select
    acc.id,
    balance,
    currency
from public.account acc
left join public.account_balance acb
    on acc.id = acb.id
where
    acc.id = $1
LIMIT 1
`

type GetAccountRow struct {
	ID       string
	Balance  sql.NullInt64
	Currency sql.NullString
}

func (q *Queries) GetAccount(ctx context.Context, id string) (GetAccountRow, error) {
	row := q.db.QueryRow(ctx, GetAccount, id)
	var i GetAccountRow
	err := row.Scan(&i.ID, &i.Balance, &i.Currency)
	return i, err
}

const ListAccounts = `-- name: ListAccounts :many
select
    acc.id,
    balance,
    currency
from
    public.account acc
inner join
    public.account_balance acb
on acc.id = acb.id
LIMIT $2
OFFSET $1
`

type ListAccountsParams struct {
	Page   int32
	Number int32
}

type ListAccountsRow struct {
	ID       string
	Balance  sql.NullInt64
	Currency sql.NullString
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]ListAccountsRow, error) {
	log.Println(arg.Page, arg.Number)
	rows, err := q.db.Query(ctx, ListAccounts, arg.Number, arg.Page)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountsRow{}
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(&i.ID, &i.Balance, &i.Currency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const TopupAccountBalance = `-- name: TopupAccountBalance :one
insert into public.account_balance (id, balance, currency)
values($1, $2, $3)
    on conflict (id)
do
update set balance = public.account_balance.balance + excluded.balance
returning id
`

type TopupAccountBalanceParams struct {
	ID       string
	Balance  sql.NullInt64
	Currency sql.NullString
}

func (q *Queries) TopupAccountBalance(ctx context.Context, arg TopupAccountBalanceParams) (TopupAccountBalanceParams, error) {
	retry, success := 0, false
	for retry < 3 && !success {
		tx, err := q.db.Begin(ctx)
		if err != nil {
			return TopupAccountBalanceParams{}, err
		}
		tx.Exec(ctx, "SET TRANSACTION ISOLATION LEVEL SERIALIZABLE")

		_, err = tx.Exec(ctx, TopupAccountBalance, arg.ID, arg.Balance, arg.Currency)
		if err != nil {
			return TopupAccountBalanceParams{}, err
		}

		if err = tx.Commit(ctx); err != nil {
			success = false
			retry++
		} else {
			success = true
		}
	}

	acc, _ := q.GetAccount(ctx, arg.ID)
	return TopupAccountBalanceParams{ID: acc.ID, Balance: acc.Balance, Currency: acc.Currency}, nil
}
